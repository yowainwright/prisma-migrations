import { existsSync, readFileSync, writeFileSync, mkdirSync } from "fs";
import { join } from "path";
import { colors } from "../../../utils/colors";

interface PackageJson {
  name?: string;
  exports?: Record<string, any>;
  [key: string]: any;
}

function readPackageJson(cwd: string): PackageJson {
  const pkgPath = join(cwd, "package.json");
  if (!existsSync(pkgPath)) {
    throw new Error(
      "package.json not found. Run this command from a package directory.",
    );
  }
  return JSON.parse(readFileSync(pkgPath, "utf-8"));
}

function writePackageJson(cwd: string, pkg: PackageJson): void {
  const pkgPath = join(cwd, "package.json");
  writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + "\n");
}

function updatePrismaSchema(schemaPath: string): void {
  if (!existsSync(schemaPath)) {
    throw new Error(`Prisma schema not found at ${schemaPath}`);
  }

  let schema = readFileSync(schemaPath, "utf-8");

  // Check if generator client already exists
  const hasGenerator = /generator\s+client\s*\{/.test(schema);

  if (hasGenerator) {
    // Update existing generator
    const hasOutput = /output\s*=/.test(schema);
    if (!hasOutput) {
      schema = schema.replace(
        /(generator\s+client\s*\{[^}]*)/,
        '$1\n  output = "../src/generated/client"',
      );
      console.log(
        colors.cyan("  Updated existing Prisma generator with custom output"),
      );
    } else {
      console.log(
        colors.yellow(
          "  Prisma generator already has custom output - skipping",
        ),
      );
    }
  } else {
    // Add generator
    const generatorBlock = `
generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}
`;
    // Insert after datasource block
    schema = schema.replace(
      /(datasource\s+\w+\s*\{[^}]*\})/,
      `$1\n${generatorBlock}`,
    );
    console.log(colors.cyan("  Added Prisma generator with custom output"));
  }

  writeFileSync(schemaPath, schema);
}

function createDbFiles(srcDir: string, packageName: string): void {
  const dbDir = join(srcDir, "db");

  if (!existsSync(dbDir)) {
    mkdirSync(dbDir, { recursive: true });
  }

  // Create types.ts (type-only exports)
  const typesPath = join(dbDir, "types.ts");
  const typesContent = `// Auto-generated by prisma-migrations
// Type-only exports - no runtime code
// Other packages can import: import type * as Prisma from "${packageName}/db/types"
export type * from '../generated/client';
`;

  writeFileSync(typesPath, typesContent);
  console.log(colors.cyan("  Created src/db/types.ts"));

  // Create index.ts (runtime exports)
  const indexPath = join(dbDir, "index.ts");
  const indexContent = `// Auto-generated by prisma-migrations
// Runtime exports with singleton client
export * from '../generated/client';
export { PrismaClient } from '../generated/client';

import { PrismaClient } from '../generated/client';
export const db = new PrismaClient();
`;

  writeFileSync(indexPath, indexContent);
  console.log(colors.cyan("  Created src/db/index.ts"));
}

function updatePackageJsonExports(
  pkg: PackageJson,
  _packageName: string,
): PackageJson {
  const updated = { ...pkg };

  if (!updated.exports) {
    updated.exports = {};
  }

  // Add db exports
  updated.exports["./db"] = {
    types: "./dist/db/index.d.ts",
    default: "./dist/db/index.js",
  };

  // Add db/types exports (type-only)
  updated.exports["./db/types"] = {
    types: "./dist/db/types.d.ts",
  };

  console.log(colors.cyan(`  Updated package.json exports`));
  return updated;
}

function updateTsConfig(cwd: string): void {
  const tsconfigPath = join(cwd, "tsconfig.json");

  if (!existsSync(tsconfigPath)) {
    console.log(
      colors.yellow(
        "  tsconfig.json not found - you may need to configure TypeScript manually",
      ),
    );
    return;
  }

  const tsconfig = JSON.parse(readFileSync(tsconfigPath, "utf-8"));

  if (!tsconfig.compilerOptions) {
    tsconfig.compilerOptions = {};
  }

  // Ensure proper settings for exports
  const updates: Record<string, any> = {
    declaration: true,
    declarationMap: true,
  };

  // Only set outDir if not already set
  if (!tsconfig.compilerOptions.outDir) {
    updates.outDir = "./dist";
  }

  let updated = false;
  for (const [key, value] of Object.entries(updates)) {
    if (tsconfig.compilerOptions[key] !== value) {
      tsconfig.compilerOptions[key] = value;
      updated = true;
    }
  }

  if (updated) {
    writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2) + "\n");
    console.log(colors.cyan("  Updated tsconfig.json"));
  }
}

function addToGitignore(cwd: string): void {
  const gitignorePath = join(cwd, ".gitignore");
  const entries = ["src/generated/", "dist/"];

  let gitignore = existsSync(gitignorePath)
    ? readFileSync(gitignorePath, "utf-8")
    : "";

  let added = false;
  for (const entry of entries) {
    if (!gitignore.includes(entry)) {
      gitignore += `\n${entry}`;
      added = true;
    }
  }

  if (added) {
    writeFileSync(gitignorePath, gitignore.trim() + "\n");
    console.log(colors.cyan("  Updated .gitignore"));
  }
}

export async function setupSource(options: {
  cwd?: string;
  skipTypes?: boolean;
}) {
  const cwd = options.cwd || process.cwd();

  console.log(colors.bold("\nSetting up source package for type exports...\n"));

  try {
    // 1. Read and validate package.json
    const pkg = readPackageJson(cwd);
    if (!pkg.name) {
      throw new Error("package.json must have a 'name' field");
    }

    console.log(colors.gray(`Package: ${colors.bold(pkg.name)}\n`));

    // 2. Update Prisma schema
    const schemaPath = join(cwd, "prisma", "schema.prisma");
    updatePrismaSchema(schemaPath);

    if (!options.skipTypes) {
      // 3. Create db files
      const srcDir = join(cwd, "src");
      if (!existsSync(srcDir)) {
        mkdirSync(srcDir, { recursive: true });
      }
      createDbFiles(srcDir, pkg.name);

      // 4. Update package.json exports
      const updatedPkg = updatePackageJsonExports(pkg, pkg.name);
      writePackageJson(cwd, updatedPkg);

      // 5. Update tsconfig.json
      updateTsConfig(cwd);

      // 6. Update .gitignore
      addToGitignore(cwd);
    }

    console.log("");
    console.log(colors.green("✓ Source package configured!"));
    console.log("");
    console.log(colors.bold("Next steps:"));
    console.log(colors.gray("  1. Run: prisma generate"));
    console.log(colors.gray("  2. Build your package: npm run build"));
    console.log(colors.gray("  3. In consumer packages, run:"));
    console.log(colors.gray(`     prisma-migrations link-types ${pkg.name}`));
    console.log("");
  } catch (error) {
    console.log("");
    console.log(
      colors.red(
        `✗ Error: ${error instanceof Error ? error.message : String(error)}`,
      ),
    );
    process.exit(1);
  }
}
